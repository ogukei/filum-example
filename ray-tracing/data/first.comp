#version 450

layout(constant_id = 0) const uint WIDTH = 8;
layout(constant_id = 1) const uint HEIGHT = 8;

#define FLT_MAX 3.402823466e+38

// @see https://www.ronja-tutorials.com/2018/09/02/white-noise.html
float rand(vec3 value) {
    return fract(sin(dot(sin(value), vec3(12.9898, 78.233, 37.719))) * 143758.5453);
}

layout(binding = 0) buffer Binding {
    vec4 image[];
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Sphere {
    vec3 center;
    float radius;
};

struct Hit {
    float t;
    vec3 p;
    vec3 normal;
};

const uint NUM_OBJECTS = 2;
const Sphere OBJECTS[NUM_OBJECTS] = Sphere[](
    Sphere(vec3(0, 0, -1), 0.5),
    Sphere(vec3(0, -100.5, -1), 100.0)
);

const uint NUM_ANTIALIASING = 100;

Ray ray(vec3 origin, vec3 direction) {
    return Ray(origin, normalize(direction));
}

vec3 rayPoint(Ray r, float t) {
    return r.origin + t * r.direction;
}

bool hitSphere(Sphere s, Ray r, float tMin, float tMax, inout Hit hit) {
    vec3 oc = r.origin - s.center;
    float a = dot(r.direction, r.direction);
    float b = dot(oc, r.direction);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = b*b - a*c;
    if (discriminant > 0) {
        float temp = (-b - sqrt(discriminant)) / a;
        if (temp < tMax && temp > tMin) {
            vec3 p = rayPoint(r, temp);
            hit.t = temp;
            hit.p = p;
            hit.normal = (p - s.center) / s.radius;
            return true;
        }
        temp = (-b + sqrt(discriminant)) / a;
        if (temp < tMax && temp > tMin) {
            vec3 p = rayPoint(r, temp);
            hit.t = temp;
            hit.p = p;
            hit.normal = (p - s.center) / s.radius;
            return true;
        }
    }
    return false;
}

bool hitObjects(Ray r, float tMin, float tMax, inout Hit hit) {
    Hit tempHit;
    bool hitAnything = false;
    float closestSoFar = tMax;
    for (uint i = 0; i < NUM_OBJECTS; i++) {
        Sphere object = OBJECTS[i];
        if (hitSphere(object, r, tMin, closestSoFar, tempHit)) {
            hitAnything = true;
            closestSoFar = tempHit.t;
            hit = tempHit;
        }
    }
    return hitAnything;
}

vec3 color(Ray r) {
    Hit hit;
    if (hitObjects(r, 0, FLT_MAX, hit)) {
        return 0.5 * (hit.normal + 1.0);
    } else {
        vec3 dir = r.direction;
        float t = 0.5 * (dir.y + 1.0);
        return (1.0 - t) * vec3(1, 1, 1) + t * vec3(0.5, 0.7, 1.0);
    }
}

struct Camera {
    vec3 origin;
    vec3 lowerLeftCorner;
    vec3 horizontal;
    vec3 vertical;
};

const Camera CAMERA = Camera(
    vec3(0, 0, 0),
    vec3(-2.0, -1.0, -1.0),
    vec3(4.0, 0, 0),
    vec3(0, 2, 0)
);

Ray cameraRay(Camera c, float u, float v) {
    return ray(c.origin, c.lowerLeftCorner + u * c.horizontal + v * c.vertical);
}

void antialiasing(Camera camera, uint ix, uint iy, uint ia, inout vec3 blended) {
    float noiseU = rand(vec3(ix, iy, ia));
    float noiseV = rand(vec3(ix, iy, 1 * NUM_ANTIALIASING + ia));
    float u = float(ix + noiseU) / float(WIDTH);
    float v = float(iy + noiseV) / float(HEIGHT);
    Ray r = cameraRay(camera, u, v);
    blended += color(r);
}

void main() {
    uint ix = gl_GlobalInvocationID.x;
    uint iy = gl_GlobalInvocationID.y;
    vec3 blended = vec3(0, 0, 0);
    for (uint ia = 0; ia < NUM_ANTIALIASING; ia++) {
        antialiasing(CAMERA, ix, iy, ia, blended);
    }
    blended /= float(NUM_ANTIALIASING);
    image[iy * WIDTH + ix] = vec4(blended, 1.0);
}
